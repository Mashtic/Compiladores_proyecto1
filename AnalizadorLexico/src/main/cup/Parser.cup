package cup;

import java_cup.runtime.*;
import jflex.LexerCup;
import type_table.TypeTable;

//////////////////////// Código ////////////////////////
action code
{:
    // Tabla de tipos
    public TypeTable typeTable = new TypeTable();

    // Manejo de errores
    public int contadorErrores = 0;

    public void revisionCodigo(){
        if (contadorErrores == 0){
            System.out.println("Código semánticamente bien estructurado");
        }
        else{
            throw new Error("Cantidad de errores semánticos encontrados: " + contadorErrores);
        }
    }

    public void errorEncontrado(){
        contadorErrores += 1;
        System.out.println("Sentencia mal estructurada");
        System.out.println("Revise la semántica");
    }
:}

parser code {:
    
    // Lectura de los tokens
    LexerCup lexer;

    @SuppressWarnings("deprecation")
    public parser(LexerCup lexer){
        this.lexer = lexer;
        this.symbolFactory = new DefaultSymbolFactory();
    }
    
    // Recuperación de errores
    public void syntax_error(Symbol s){
        System.out.println("");
        System.out.println("Error R de sintáxis:" + s.value);
        System.out.println("Línea:" + (s.left+1));
        System.out.println("Columna:" + (s.right+1));
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("");
        System.out.println("Error NR de sintáxis:" + s.value);
        System.out.println("Línea:" + (s.left+1));
        System.out.println("Columna:" + (s.right+1));
    }

:}

init with {: :};

scan with {: return lexer.next_token(); :};

//////////////////////// Terminales ////////////////////////
/* Identificadores */
terminal MAIN, IDENTIFICADOR;

/* Tipos */
terminal INTEGER, FLOAT, BOOL, CHAR, STRING;

/* Literales */
terminal LIT_INTEGER, LIT_FLOAT, LIT_CHAR, LIT_STRING, LIT_BOOL;

/* Operadores aritméticos */
terminal SUMA, RESTA, DIVISION, MULTIPLICACION,
        MODULO, POTENCIA, INCREMENTO, DECREMENTO;

/* Operadores relacionales */
terminal MENOR, MENOR_IGUAL, MAYOR,
        MAYOR_IGUAL, IGUALDAD, DIFERENTE;

/* Operadores lógicos */
terminal CONJUNCION, DISYUNCION, NEGACION;

/* Estructuras de control */
terminal IF, ELSE, WHILE, FOR,
        SWITCH, CASE, DEFAULT, BREAK,
        RETURN, DOS_PUNTOS;

/* Símbolos de estructura */
terminal COMA, PUNTO_COMA, NEGATIVO, BLOQUE_A,
        BLOQUE_C, CORCHETE_A, CORCHETE_C,
        PARENTESIS_A, PARENTESIS_C, ASIGNACION, DELIMITADOR;

/* Operaciones de lectura */
terminal PRINT, READ;

//////////////////////// No terminales ////////////////////////
/* Main */
non terminal programa;

/* Funciones */
non terminal funciones, funcion, encabezado_func;

/* Llamado de funciones */
non terminal func_call, parametros_call, param_call_aux;

/* Parámetros */
non terminal parametros, param_aux, parametro;

/* Bloques */
non terminal bloque, instrucciones, sentencia;

/* Expresiones */
non terminal expresion, expresion_aritmetica, expresion_relacional, expresion_logica;

/* Creaciones */
non terminal creacion, creacion_izq, creacion_variable, creacion_arreglos;

/* Asignaciones */
non terminal asignacion, asignacion_variable, asignacion_arreglos, asignacion_operacion;

/* Condicionales */
non terminal condicional, condicional_aux, condicional_if;

/* Iteraciones */
non terminal iteracion, iteracion_while, iteracion_for;

/* Switch */
non terminal switch, casos_con_default, casos_aux, caso;

/* Entrada y salida */
non terminal salida, entrada;

/* Retorno */
non terminal return;

/* Break */
non terminal break;

/* Generales */
non terminal operadores_aritmeticos, operadores_relacionales, operadores_logicos, operadores_unarios;

/* Generales */
non terminal factor, tipos, literales, num_negativos, operacion_unaria, valores_arreglos, identificador_func;

//////////////////////// Precedencia ////////////////////////
// Operadores aritméticos
precedence left INCREMENTO, DECREMENTO;
precedence left SUMA, RESTA;
precedence left DIVISION, MULTIPLICACION;
precedence left MODULO;
precedence left POTENCIA;

// Operadores relacionales
precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;

// Operadores lógicos
precedence left CONJUNCION, DISYUNCION;
precedence left NEGACION;

// Otros
precedence left DELIMITADOR, PARENTESIS_C, IF, IDENTIFICADOR;

//////////////////////// Producciones ////////////////////////
/********************** Inicio **********************/
start with programa;

/********************** Programa **********************/
/* Sirve para revisar los errores del código y mostrar la tabla de símbolos */
programa ::= funciones {:
                        revisionCodigo();
                        System.out.println(typeTable.toString());
                   :};

/********************** Funciones **********************/
funciones ::= funcion               // Reducción
            | funciones funcion;    // Recursividad de funciones

funcion ::= encabezado_func bloque;

encabezado_func ::= tipos:t identificador_func:id parametros
                    {: typeTable.addTable(t.toString(), id.toString()); :}; //
                    
/********************** Llamado de función **********************/

func_call ::= IDENTIFICADOR parametros_call;

parametros_call ::= PARENTESIS_A PARENTESIS_C
             | PARENTESIS_A param_call_aux PARENTESIS_C;

param_call_aux ::= expresion
                 | param_call_aux COMA expresion;

/********************** Parámetros **********************/
parametros ::= PARENTESIS_A PARENTESIS_C            // Cero argumentos
            | PARENTESIS_A param_aux PARENTESIS_C;  // Uno o más argumentos

param_aux ::= parametro
            | param_aux COMA parametro;

parametro ::= tipos IDENTIFICADOR;

/********************** Bloques **********************/
bloque ::= BLOQUE_A instrucciones BLOQUE_C;

instrucciones ::= sentencia
                | instrucciones sentencia;

sentencia ::= expresion DELIMITADOR
            | creacion DELIMITADOR
            | asignacion DELIMITADOR
            | condicional
            | iteracion
            | switch
            | entrada DELIMITADOR
            | salida DELIMITADOR
            | return DELIMITADOR
            | break DELIMITADOR
            | PARENTESIS_A sentencia PARENTESIS_C
            | error:e DELIMITADOR {: errorEncontrado(); :}
            | error:e BLOQUE_C {: errorEncontrado(); :};

/********************** Expresiones **********************/
expresion ::= expresion_aritmetica
            | expresion_relacional
            | expresion_logica
            | PARENTESIS_A expresion PARENTESIS_C
            | factor;

expresion_aritmetica ::= expresion operadores_aritmeticos factor;

expresion_relacional ::= expresion operadores_relacionales expresion;

expresion_logica ::= expresion operadores_logicos expresion
                    | NEGACION expresion;

/********************** Creaciones **********************/
creacion ::= creacion_variable
            | creacion_arreglos;
            
creacion_izq ::= tipos:t IDENTIFICADOR:id {: typeTable.addRow(t.toString(), id.toString()); :};      

creacion_variable ::= creacion_izq 
                | creacion_izq ASIGNACION expresion;

creacion_arreglos ::= creacion_izq CORCHETE_A expresion CORCHETE_C
                | creacion_izq CORCHETE_A expresion CORCHETE_C ASIGNACION CORCHETE_A valores_arreglos CORCHETE_C
                | creacion_izq CORCHETE_A CORCHETE_C ASIGNACION CORCHETE_A valores_arreglos CORCHETE_C;

/********************** Asignaciones **********************/
asignacion ::= asignacion_variable
             | asignacion_arreglos
             | asignacion_operacion;

asignacion_variable ::= IDENTIFICADOR ASIGNACION expresion;

asignacion_arreglos ::= IDENTIFICADOR CORCHETE_A expresion CORCHETE_C ASIGNACION expresion;

asignacion_operacion ::= IDENTIFICADOR operadores_aritmeticos ASIGNACION expresion;

/********************** Condicionales **********************/
condicional ::= condicional_aux
              | condicional_aux ELSE bloque;

condicional_aux ::= condicional_if
                | condicional_aux condicional_if;

condicional_if ::= IF PARENTESIS_A expresion PARENTESIS_C bloque;

/********************** Iteraciones **********************/
iteracion ::= iteracion_while
            | iteracion_for;

iteracion_while ::= WHILE PARENTESIS_A expresion PARENTESIS_C bloque;

iteracion_for ::= FOR PARENTESIS_A creacion_variable PUNTO_COMA expresion PUNTO_COMA operacion_unaria PARENTESIS_C bloque
                | FOR PARENTESIS_A asignacion_variable PUNTO_COMA expresion PUNTO_COMA operacion_unaria PARENTESIS_C bloque;

/********************** Switch **********************/
switch ::= SWITCH PARENTESIS_A expresion PARENTESIS_C BLOQUE_A casos_con_default BLOQUE_C;

casos_con_default ::= casos_aux
                    | casos_aux DEFAULT DOS_PUNTOS instrucciones;

casos_aux ::= caso
        | casos_aux caso;

caso ::= CASE literales DOS_PUNTOS instrucciones;

/********************** Entrada y salida **********************/
entrada ::= READ PARENTESIS_A IDENTIFICADOR PARENTESIS_C;

salida ::= PRINT PARENTESIS_A expresion PARENTESIS_C ;

/********************** Break **********************/
break ::= BREAK;

/********************** Retorno **********************/
return ::= RETURN
          | RETURN expresion;

/********************** Generales **********************/
factor ::= IDENTIFICADOR
        | IDENTIFICADOR CORCHETE_A expresion CORCHETE_C
        | literales
        | operacion_unaria
        | num_negativos
        | func_call;

tipos ::= INTEGER:i {: RESULT = i.toString(); :}
        | FLOAT:i {: RESULT = i.toString(); :}
        | CHAR:i {: RESULT = i.toString(); :}
        | STRING:i {: RESULT = i.toString(); :}
        | BOOL:i {: RESULT = i.toString(); :};

literales ::= LIT_INTEGER:i {: RESULT = i.toString(); :}
            | LIT_FLOAT:i {: RESULT = i.toString(); :}
            | LIT_CHAR:i {: RESULT = i.toString(); :}
            | LIT_STRING:i {: RESULT = i.toString(); :}
            | LIT_BOOL:i {: RESULT = i.toString(); :};

num_negativos ::= NEGATIVO LIT_INTEGER:i {: RESULT = i.toString(); :}
                | NEGATIVO LIT_FLOAT:i {: RESULT = i.toString(); :}
                | NEGATIVO IDENTIFICADOR:i {: RESULT = i.toString(); :};

operacion_unaria ::= IDENTIFICADOR operadores_unarios;

valores_arreglos ::= expresion
                    | valores_arreglos COMA expresion;

identificador_func ::= IDENTIFICADOR:i {: RESULT = i.toString(); :}
                    | MAIN:i {: RESULT = i.toString(); :};

/********************** Operadores **********************/
operadores_aritmeticos ::= SUMA:i {: RESULT = i.toString(); :}
                | RESTA:i {: RESULT = i.toString(); :}
                | MULTIPLICACION:i {: RESULT = i.toString(); :}
                | DIVISION:i {: RESULT = i.toString(); :}
                | MODULO:i {: RESULT = i.toString(); :}
                | POTENCIA:i {: RESULT = i.toString(); :};

operadores_relacionales ::= MENOR:i {: RESULT = i.toString(); :}
                    | MENOR_IGUAL:i {: RESULT = i.toString(); :}
                    | MAYOR:i {: RESULT = i.toString(); :}
                    | MAYOR_IGUAL:i {: RESULT = i.toString(); :}
                    | IGUALDAD:i {: RESULT = i.toString(); :}
                    | DIFERENTE:i {: RESULT = i.toString(); :};

operadores_logicos ::= CONJUNCION:i {: RESULT = i.toString(); :}
                | DISYUNCION:i {: RESULT = i.toString(); :};

operadores_unarios ::= INCREMENTO:i {: RESULT = i.toString(); :}
                    | DECREMENTO:i {: RESULT = i.toString(); :};