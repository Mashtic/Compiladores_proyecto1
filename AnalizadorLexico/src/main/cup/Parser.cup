package cup;

import java_cup.runtime.*;
import jflex.LexerCup;
import type_table.TypeTable;
import type_table.ValidateTypes;
import java.util.Arrays;

//////////////////////// Código ////////////////////////
action code
{:
    // Ubicación
    public int numFunc = 0;
    public int numSent = 0;

    public int cantParam = 0;

    public void incNumSent(){
        numSent = numSent+1;
    }

    // Tabla de tipos
    public TypeTable typeTable = new TypeTable();

    // Manejo de errores
    // Errores sintacticos
    public int contadorErroresSintacticos = 0;

    public void revisionSintacticaCodigo(){
        if (contadorErroresSintacticos == 0){
            System.out.println("Código sintácticamente bien estructurado");
        }
        else{
            throw new Error("Cantidad de errores sintácticos encontrados: " + contadorErroresSintacticos);
        }
    }

    public void errorSintacticoEncontrado(){
        contadorErroresSintacticos += 1;
        System.out.println("Sentencia mal estructurada");
        System.out.println("Revise la sintaxis");
    }

    // Errores semanticos
    public int contadorErroresSemanticos = 0;

    public void revisionSemanticaCodigo(){
        if (contadorErroresSemanticos == 0){
            System.out.println("Código semánticamente bien estructurado");
        }
        else{
            throw new Error("Cantidad de errores semánticos encontrados: " + contadorErroresSemanticos);
        }
    }

    public void errorSemanticoEncontrado(String val, String explicacion){
        contadorErroresSemanticos += 1;
        System.out.println("");
        System.out.println("Error Semántico #" + Integer.toString(contadorErroresSemanticos));
        System.out.println("Error semántico recuperable de semántica:" + val);
        System.out.println(explicacion);
        System.out.println("Función #" + numFunc);
        System.out.println("Sentencia #" + numSent);
    }

    // Producciones
    public boolean existingFunction(String id){
        return !typeTable.getTableType(id).equals(ValidateTypes.ERROR);
    }

    public boolean existingIdScope(String id){
        return !typeTable.getRowTypeCurrentHash(id).equals(ValidateTypes.ERROR);
    }

    public String getTypeIdScope(String id){
        return typeTable.getRowTypeCurrentHash(id);
    }

    public String compareTypes(String exp_1, String exp_2){
        String expS_1 = ValidateTypes.getType(exp_1);
        String expS_2 = ValidateTypes.getType(exp_2);
        if (expS_1.equals(ValidateTypes.ERROR) || expS_2.toString().equals(ValidateTypes.ERROR)) {
            return ValidateTypes.ERROR;
        }
        else if (!expS_1.equals(expS_2)) {
            return ValidateTypes.ERROR;
        }
        else{
            return ValidateTypes.getType(expS_1.toString());
        }
    }

    public String getVariableTypeNum(String id){
        if (!existingIdScope(id.toString())){
            errorSemanticoEncontrado(id.toString(),
            "El identificador no se declaró previamente en la función");
            return ValidateTypes.ERROR;
        }
        else if (!validateNumber(id.toString())){
            errorSemanticoEncontrado(id.toString(),
            "El identificador debe ser de tipo entero o float");
            return ValidateTypes.ERROR;
        }
        else {
            return getTypeIdScope(id.toString());
        }
    }

    public String getFuncCall(String i, String p){
        boolean flag_param = ValidateTypes.validateCallFuncTypes(p.toString(),
                                    typeTable.getTableParamsType(i.toString()));
        if (!existingFunction(i.toString())) {
            errorSemanticoEncontrado(i.toString(),
            "La función no se ha encontrado");
            return ValidateTypes.ERROR;
        }
        else if (!flag_param) {
            errorSemanticoEncontrado(i.toString(),
            "Los parámetros de la función no coinciden con la llamada");
            return ValidateTypes.ERROR;
        }
        else {
            return ValidateTypes.getType(typeTable.getTableType(i));
        }
    }

    public boolean validateNumber(String id){
        String val = typeTable.getRowTypeCurrentHash(id);;
        return ValidateTypes.validateNumber(val);
    }
:}

parser code {:

    // Lectura de los tokens
    LexerCup lexer;

    @SuppressWarnings("deprecation")
    public parser(LexerCup lexer){
        this.lexer = lexer;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    // Recuperación de errores
    public void syntax_error(Symbol s){
        System.out.println("");
        System.out.println("Error sintáctico recuperable de sintáxis:" + s.value);
        System.out.println("Línea:" + (s.left+1));
        System.out.println("Columna:" + (s.right+1));
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("");
        System.out.println("Error sintáctico no recuperable de sintáxis:" + s.value);
        System.out.println("Línea:" + (s.left+1));
        System.out.println("Columna:" + (s.right+1));
    }

:}

init with {: :};

scan with {: return lexer.next_token(); :};

//////////////////////// Terminales ////////////////////////
/* Identificadores */
terminal MAIN, IDENTIFICADOR;

/* Tipos */
terminal INTEGER, FLOAT, BOOL, CHAR, STRING;

/* Literales */
terminal LIT_INTEGER, LIT_FLOAT, LIT_CHAR, LIT_STRING, LIT_BOOL;

/* Operadores aritméticos */
terminal SUMA, RESTA, DIVISION, MULTIPLICACION,
        MODULO, POTENCIA, INCREMENTO, DECREMENTO;

/* Operadores relacionales */
terminal MENOR, MENOR_IGUAL, MAYOR,
        MAYOR_IGUAL, IGUALDAD, DIFERENTE;

/* Operadores lógicos */
terminal CONJUNCION, DISYUNCION, NEGACION;

/* Estructuras de control */
terminal IF, ELSE, WHILE, FOR,
        SWITCH, CASE, DEFAULT, BREAK,
        RETURN, DOS_PUNTOS;

/* Símbolos de estructura */
terminal COMA, PUNTO_COMA, NEGATIVO, BLOQUE_A,
        BLOQUE_C, CORCHETE_A, CORCHETE_C,
        PARENTESIS_A, PARENTESIS_C, ASIGNACION, DELIMITADOR;

/* Operaciones de lectura */
terminal PRINT, READ;

//////////////////////// No terminales ////////////////////////
/* Main */
non terminal programa;

/* Funciones */
non terminal funciones, funcion, encabezado_func;

/* Llamado de funciones */
non terminal func_call, parametros_call, param_call_aux;

/* Parámetros */
non terminal parametros, param_aux, parametro;

/* Bloques */
non terminal bloque, instrucciones, instruccion, estructuras, sentencia;

/* Expresiones */
non terminal expresion, expresion_aritmetica, expresion_relacional, expresion_logica;

/* Creaciones */
non terminal creacion, creacion_variable, creacion_arreglos;

/* Asignaciones */
non terminal asignacion, asignacion_variable, asignacion_arreglos;

/* Condicionales */
non terminal condicional, condicional_aux, condicional_if;

/* Iteraciones */
non terminal iteracion, iteracion_while, iteracion_for;

/* Switch */
non terminal switch, casos_con_default, casos_aux, caso;

/* Entrada y salida */
non terminal salida, entrada;

/* Retorno */
non terminal return;

/* Break */
non terminal break;

/* Generales */
non terminal operadores_aritmeticos, operadores_relacionales, operadores_logicos, operadores_unarios;

/* Generales */
non terminal factor, tipos, literales, num_negativos, operacion_unaria, valores_arreglos, identificador_func;

//////////////////////// Precedencia ////////////////////////
// Operadores aritméticos
precedence left INCREMENTO, DECREMENTO;
precedence left SUMA, RESTA;
precedence left DIVISION, MULTIPLICACION;
precedence left MODULO;
precedence left POTENCIA;

// Operadores relacionales
precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;

// Operadores lógicos
precedence left CONJUNCION, DISYUNCION;
precedence left NEGACION;

// Otros
precedence left DELIMITADOR, PARENTESIS_C, IF, IDENTIFICADOR, CORCHETE_A;

//////////////////////// Producciones ////////////////////////
/********************** Inicio **********************/
start with programa;

/********************** Programa **********************/
/* Sirve para revisar los errores del código y mostrar la tabla de símbolos */
programa ::= funciones {:
                            System.out.println(typeTable.toString());
                            revisionSintacticaCodigo();
                            revisionSemanticaCodigo();
                       :};

/********************** Funciones **********************/
funciones ::= funcion               // Reducción
            | funciones funcion;    // Recursividad de funciones

identificador_func ::= IDENTIFICADOR:i {: RESULT = i.toString(); :}
                    | MAIN:i {: RESULT = i.toString(); :};

encabezado_func ::= tipos:t identificador_func:id parametros:p
                    {:
                        if (existingFunction(id.toString())) {
                            errorSemanticoEncontrado(id.toString(),
                              "La función se definió previamente en el código");
                              RESULT = "error";
                        }

                        if (!p.toString().equals("null")){
                            String[] paramsInfo;
                            if (p.toString().contains(":")) {
                                paramsInfo = p.toString().split(":");
                            } else {
                                paramsInfo = new String[]{p.toString()};
                            }
                            String resultParam = "";
                            for (int i = 0; i < paramsInfo.length; i++) {
                                String[] paramInfo = paramsInfo[i].split("-");
                                resultParam += paramInfo[0];
                                if (i != paramsInfo.length-1){
                                    resultParam += ":";
                                }
                            }
                            typeTable.addTable(t.toString(), id.toString(), resultParam);

                            for (int i = 0; i < paramsInfo.length; i++) {
                                String[] paramInfo = paramsInfo[i].split("-");
                                typeTable.addRow(paramInfo[1], paramInfo[2], paramInfo[3]);
                            }
                        }
                        else{
                            typeTable.addTable(t.toString(), id.toString(), "null");
                        }
                    :};

funcion ::= {: numFunc += 1; numSent = 0; :} encabezado_func bloque;

/********************** Parámetros **********************/
parametros ::= PARENTESIS_A PARENTESIS_C  {: RESULT = "null"; :}           // Cero argumentos
            | PARENTESIS_A param_aux:p PARENTESIS_C {: RESULT = p.toString(); :};  // Uno o más argumentos


param_aux ::= parametro:p {: RESULT = p.toString(); :}
            | param_aux:p1 COMA parametro:p2 {: RESULT = p1.toString() + ":" + p2.toString(); :};

parametro ::= tipos:t IDENTIFICADOR:id {:
                                        if (existingIdScope(id.toString())) {
                                            errorSemanticoEncontrado(id.toString(),
                                              "El parámetro se definió previamente en la función");
                                              RESULT = ValidateTypes.ERROR;
                                        }
                                        else{
                                            RESULT = ValidateTypes.getType(t.toString()) + "-" + t.toString() + "-" + id.toString() + "-" + "asignado";
                                        }
                                    :};

/********************** Bloques **********************/
bloque ::= BLOQUE_A instrucciones BLOQUE_C;

instrucciones ::= instruccion
                | instrucciones instruccion;

instruccion ::= {: incNumSent(); :} estructuras
                | {: incNumSent(); :} sentencia DELIMITADOR
                | error:e DELIMITADOR {: errorSintacticoEncontrado(); :}
                | error:e BLOQUE_C {: errorSintacticoEncontrado(); :};

estructuras ::= condicional
              | iteracion
              | switch;

sentencia ::= expresion
          | creacion
          | asignacion
          | entrada
          | salida
          | return
          | break;

/********************** Expresiones **********************/
expresion ::= PARENTESIS_A expresion:i  PARENTESIS_C {: RESULT = i.toString(); :}
            | expresion_logica:i   {: RESULT = i.toString(); :};

expresion_logica ::= expresion_logica:v1 operadores_logicos:op expresion_relacional:v2 {:
                                  if (!ValidateTypes.validateExprLog(v1.toString()) || !ValidateTypes.validateExprLog(v2.toString())) {
                                      errorSemanticoEncontrado(v1.toString() + " " + op.toString() + " " + v2.toString(),
                                      "El valor, identificador o expresión en ambos lados debe resultar en booleano");
                                      RESULT = ValidateTypes.ERROR;
                                  }
                                  else{
                                      RESULT = ValidateTypes.E_BOOL;
                                    }
                              :}
                    | NEGACION:n expresion_relacional:v1   {:
                                      if (!ValidateTypes.validateExprLog(v1.toString())) {
                                          errorSemanticoEncontrado(n.toString() + " " + v1.toString(),
                                          "El valor, identificador o expresión negado debe resultar en booleano");
                                          RESULT = ValidateTypes.ERROR;
                                      }
                                      else{
                                        RESULT = ValidateTypes.E_BOOL;
                                      }
                                  :}
                    | expresion_relacional:i   {: RESULT = i.toString(); :};

expresion_relacional ::= expresion_aritmetica:v1 operadores_relacionales:op expresion_aritmetica:v2 {:
                                    if (ValidateTypes.validateExprRelNum(v1.toString(), v2.toString(), op.toString()) ||
                                        ValidateTypes.validateExprRelBool(v1.toString(), v2.toString(), op.toString())){
                                        RESULT = ValidateTypes.E_BOOL;
                                    }
                                    else {
                                        errorSemanticoEncontrado(v1.toString() + " " + op.toString() + " " + v2.toString(),
                                        "El valor, identificador o expresión en ambos lados debe resultar en booleano o integer/float");
                                        RESULT = ValidateTypes.ERROR;
                                    }
                                :}
                         | PARENTESIS_A expresion_relacional:i PARENTESIS_C  {: RESULT = i.toString(); :}
                        | expresion_aritmetica:i   {: RESULT = i.toString(); :};

expresion_aritmetica ::= expresion_aritmetica:v1 operadores_aritmeticos:op factor:v2 {:
                                        if (!ValidateTypes.validateNumber(v1.toString())) {
                                            errorSemanticoEncontrado(v1.toString() + " " + op.toString() + " " + v2.toString(),
                                            "El valor o identificador deber ser entero o decimal");
                                            RESULT = ValidateTypes.ERROR;
                                        }
                                        else if (!ValidateTypes.validateNumber(v2.toString())) {
                                            errorSemanticoEncontrado(v2.toString(),
                                            "El valor o identificador deber ser entero o decimal");
                                            RESULT = ValidateTypes.ERROR;
                                        }
                                        else {
                                            RESULT = ValidateTypes.evaluateResultExpr(v1.toString(), v2.toString());
                                        }
                                    :}
                       | PARENTESIS_A expresion_aritmetica:i PARENTESIS_C  {: RESULT = i.toString(); :}
                       | factor:i   {: RESULT = i.toString(); :};

/********************** Creaciones **********************/
creacion ::= creacion_variable
            | creacion_arreglos;

creacion_variable ::= tipos:t IDENTIFICADOR:id {: typeTable.addRow(t.toString(), id.toString(), "declarado");
                                                  RESULT = t.toString(); :}
                | tipos:t IDENTIFICADOR:id ASIGNACION expresion:exp
                {:
                    if (existingIdScope(id.toString())) {
                        errorSemanticoEncontrado(id.toString(),
                          "La variable se definió previamente en la función");
                          RESULT = ValidateTypes.ERROR;
                    }
                    else if (!ValidateTypes.validateTypesAsign(ValidateTypes.getType(t.toString()), exp.toString())){
                        errorSemanticoEncontrado(ValidateTypes.getType(t.toString()) + " -> " + exp.toString(),
                                                "El tipo de la variable no coincide con el valor asignado");
                        RESULT = ValidateTypes.ERROR;
                    }
                    else{
                        typeTable.addRow(t.toString(), id.toString(), "asignado");
                        RESULT = t.toString();
                    }
                :};

creacion_arreglos ::= tipos:t IDENTIFICADOR:id CORCHETE_A expresion_aritmetica:exp CORCHETE_C
            {:
                if (existingIdScope(id.toString())) {
                    errorSemanticoEncontrado(id.toString(),
                      "La variable se definió previamente en la función");
                      RESULT = ValidateTypes.ERROR;
                }
                else if (!ValidateTypes.validateInteger(exp.toString())){
                    errorSemanticoEncontrado(t.toString() + " [ " + exp.toString() + " ]",
                                       "Dentro de los corchetes, debe ingresarse un entero para indicar su tamaño");
                    RESULT = ValidateTypes.ERROR;
                }
                else{
                    typeTable.addRow(t.toString(), id.toString(), "declarado");
                    RESULT = t.toString();
                }
            :}
                | tipos:t IDENTIFICADOR:id CORCHETE_A expresion_aritmetica:exp CORCHETE_C ASIGNACION CORCHETE_A valores_arreglos:val CORCHETE_C
                {:
                    if (existingIdScope(id.toString())) {
                        errorSemanticoEncontrado(id.toString(),
                          "La variable se definió previamente en la función");
                          RESULT = ValidateTypes.ERROR;
                    }
                    else if (!ValidateTypes.validateInteger(exp.toString())){
                        errorSemanticoEncontrado(t.toString() + " [ " + exp.toString() + " ]",
                                           "Dentro de los corchetes, debe ingresarse un entero para indicar su tamaño");
                        RESULT = ValidateTypes.ERROR;
                    }
                    else if (!ValidateTypes.validateTypesAsign(
                                        ValidateTypes.getType(t.toString()),
                                        val.toString())){
                        errorSemanticoEncontrado(t.toString() + " -> " + val.toString(),
                                           "El tipo de la variable no coincide con el valor asignado");
                        RESULT = ValidateTypes.ERROR;
                    }
                    else{
                        typeTable.addRow(t.toString(), id.toString(), "asignado");
                        RESULT = t.toString();
                    }
                :}
                | tipos:t IDENTIFICADOR:id CORCHETE_A CORCHETE_C ASIGNACION CORCHETE_A expresion:val CORCHETE_C
                {:
                    if (existingIdScope(id.toString())) {
                        errorSemanticoEncontrado(id.toString(),
                          "La variable se definió previamente en la función");
                          RESULT = ValidateTypes.ERROR;
                    }
                    else if (!ValidateTypes.validateTypesAsign(
                                        ValidateTypes.getType(t.toString()),
                                        val.toString())){
                        errorSemanticoEncontrado(t.toString() + " -> " + val.toString(),
                                           "El tipo de la variable no coincide con el valor asignado");
                        RESULT = ValidateTypes.ERROR;
                    }
                    else{
                        typeTable.addRow(t.toString(), id.toString(), "asignado");
                        RESULT = t.toString();
                    }
                :};

/********************** Asignaciones **********************/
asignacion ::= asignacion_variable
             | asignacion_arreglos;

asignacion_variable ::= IDENTIFICADOR:id ASIGNACION expresion:exp {:
                           if (!existingIdScope(id.toString())){
                               errorSemanticoEncontrado(id.toString(),
                               "El identificador no se declaró previamente en la función");
                               RESULT = ValidateTypes.ERROR;
                           }
                           else if (!ValidateTypes.validateTypesAsign(
                                                        ValidateTypes.getType(
                                                            typeTable.getRowTypeCurrentHash(id.toString())),
                                                        exp.toString())){
                               errorSemanticoEncontrado(ValidateTypes.getType(typeTable.getRowTypeCurrentHash(id.toString())) + " -> " + exp.toString(),
                                                       "El tipo de la variable no coincide con el valor asignado");
                               RESULT = ValidateTypes.ERROR;
                           }
                           else { typeTable.updateRowStatus(id.toString()); }
                       :};

asignacion_arreglos ::= IDENTIFICADOR:id CORCHETE_A expresion_aritmetica:exp_a CORCHETE_C ASIGNACION expresion:exp
                        {:
                           if (!existingIdScope(id.toString())){
                               errorSemanticoEncontrado(id.toString(),
                               "El identificador no se declaró previamente en la función");
                               RESULT = ValidateTypes.ERROR;
                           }
                           else if (!ValidateTypes.validateNumber(exp_a.toString())){
                             errorSemanticoEncontrado(exp_a.toString(),
                             "La posición del arreglo debe ser un valor entero");
                             RESULT = ValidateTypes.ERROR;
                           }
                           else if (!ValidateTypes.validateTypesAsign(
                                                        ValidateTypes.getType(
                                                            typeTable.getRowTypeCurrentHash(id.toString())),
                                                        exp.toString())){
                               errorSemanticoEncontrado(ValidateTypes.getType(typeTable.getRowTypeCurrentHash(id.toString())) + " -> " + exp.toString(),
                                                       "El tipo de la variable no coincide con el valor asignado");
                               RESULT = ValidateTypes.ERROR;
                           }
                           else { typeTable.updateRowStatus(id.toString()); }
                       :};

/********************** Condicionales **********************/
condicional ::= condicional_aux
              | condicional_aux ELSE bloque;

condicional_aux ::= condicional_if
                | condicional_aux condicional_if;

condicional_if ::= IF PARENTESIS_A expresion_relacional:exp PARENTESIS_C bloque
                    {:
                        if (!ValidateTypes.validateExprLog(exp.toString())) {
                              errorSemanticoEncontrado("if (" + exp.toString() + ")",
                              "El valor, identificador o expresión debe resultar en booleano");
                              RESULT = ValidateTypes.ERROR;
                          }
                    :};

/********************** Iteraciones **********************/
iteracion ::= iteracion_while
            | iteracion_for;

iteracion_while ::= WHILE PARENTESIS_A expresion_relacional:exp PARENTESIS_C bloque
                    {:
                        if (!ValidateTypes.validateExprLog(exp.toString())) {
                              errorSemanticoEncontrado("while (" + exp.toString() + ")",
                              "El valor, identificador o expresión debe resultar en booleano");
                              RESULT = ValidateTypes.ERROR;
                          }
                    :};

iteracion_for ::= FOR PARENTESIS_A creacion_variable:crea PUNTO_COMA expresion_relacional:exp PUNTO_COMA
                                    operacion_unaria:op PARENTESIS_C bloque
                    {:
                        if (crea.toString().equals(ValidateTypes.ERROR)){
                            errorSemanticoEncontrado("for ( " + crea.toString()+ " )",
                              "La creación cuenta con errores");
                              RESULT = ValidateTypes.ERROR;
                        }
                        if (!ValidateTypes.validateExprLog(exp.toString())) {
                              errorSemanticoEncontrado("for ( " + exp.toString() + " )",
                              "El valor, identificador o expresión de la expresión debe resultar en booleano");
                              RESULT = ValidateTypes.ERROR;
                          }
                        if (op.toString().equals(ValidateTypes.ERROR)){
                              errorSemanticoEncontrado("for ( " + op.toString() + " )",
                              "La expresión debe ser de la forma 'número operador_unario'");
                              RESULT = ValidateTypes.ERROR;
                          }
                    :}
                | FOR PARENTESIS_A asignacion_variable:asign PUNTO_COMA expresion_relacional:exp PUNTO_COMA
                                    operacion_unaria:op PARENTESIS_C bloque
                {:
                    if (asign.toString().equals(ValidateTypes.ERROR)){
                        errorSemanticoEncontrado("for ( " + asign.toString()+ " )",
                          "La asginación cuenta con errores semánticos");
                          RESULT = ValidateTypes.ERROR;
                    }
                    if (!ValidateTypes.validateExprLog(exp.toString())) {
                          errorSemanticoEncontrado("for ( " + exp.toString() + " )",
                          "El valor, identificador o expresión de la expresión debe resultar en booleano");
                          RESULT = ValidateTypes.ERROR;
                      }
                    if (op.toString().equals(ValidateTypes.ERROR)){
                          errorSemanticoEncontrado("for ( " + op.toString() + " )",
                          "La expresión debe ser de la forma 'número operador_unario'");
                          RESULT = ValidateTypes.ERROR;
                      }
                :};

/********************** Switch **********************/
switch ::= SWITCH PARENTESIS_A expresion:exp_1 PARENTESIS_C BLOQUE_A casos_con_default:exp_2 BLOQUE_C
                {:
                    if (!ValidateTypes.validateTypesAsign(exp_1.toString(), exp_2.toString())){
                        errorSemanticoEncontrado(exp_1.toString() + " -> " + exp_2.toString(),
                                                "El valor comparado con los case es diferente");
                        RESULT = ValidateTypes.ERROR;
                    }
                :};

casos_con_default ::= casos_aux:exp_1 {: RESULT = exp_1.toString(); :}
                    | casos_aux:exp_1 DEFAULT DOS_PUNTOS instrucciones {: RESULT = exp_1.toString(); :};

casos_aux ::= caso:exp_1 {: RESULT = ValidateTypes.getType(exp_1.toString()); :}
        | casos_aux:exp_1 caso:exp_2 {:
            String expS_1 = ValidateTypes.getType(exp_1.toString());
            String expS_2 = ValidateTypes.getType(exp_2.toString());
            if (expS_1.equals(ValidateTypes.ERROR) || expS_2.toString().equals(ValidateTypes.ERROR)) {
                RESULT = ValidateTypes.ERROR;
            }
            else if (expS_1.equals(expS_2)) {
                RESULT = expS_1;
            }
            else{
                RESULT = ValidateTypes.ERROR;
            }
        :};

caso ::= CASE literales:i DOS_PUNTOS instrucciones {: RESULT = i.toString(); :};

/********************** Entrada y salida **********************/
entrada ::= READ PARENTESIS_A IDENTIFICADOR:id PARENTESIS_C
            {:
                if (!existingIdScope(id.toString())){
                    errorSemanticoEncontrado("READ ( " + id.toString() + " )",
                    "La variable no se declaró previamente a su llamado");
                    RESULT = ValidateTypes.ERROR;
                }
                else if (!ValidateTypes.validatePrintRead(ValidateTypes.getType(typeTable.getRowTypeCurrentHash(id.toString())))){
                    errorSemanticoEncontrado("PRINT ( " + ValidateTypes.getType(typeTable.getRowTypeCurrentHash(id.toString())) + " )",
                      "La expresión debe ser char, string, int o float");
                      RESULT = ValidateTypes.ERROR;
                }
                else { typeTable.updateRowStatus(id.toString()); }
            :};

salida ::= PRINT PARENTESIS_A expresion:exp PARENTESIS_C
            {:
                String expS_1 = exp.toString();
                if (expS_1.equals(ValidateTypes.ERROR)) {
                      errorSemanticoEncontrado("PRINT ( " + exp.toString() + " )",
                      "La expresión tuvo un error al definirse");
                      RESULT = ValidateTypes.ERROR;
                }
                else if (!ValidateTypes.validatePrintRead(exp.toString())){
                    errorSemanticoEncontrado("PRINT ( " + exp.toString() + " )",
                      "La expresión debe ser char, string, int o float");
                      RESULT = ValidateTypes.ERROR;
                }
            :};

/********************** Break **********************/
break ::= BREAK;

/********************** Retorno **********************/
return ::= RETURN
          | RETURN expresion:exp {:
                                 String expS_1 = exp.toString();
                                 if (expS_1.equals(ValidateTypes.ERROR)) {
                                   errorSemanticoEncontrado("PRINT ( " + exp.toString() + " )",
                                   "La expresión retornada tuvo un error al definirse");
                                   RESULT = ValidateTypes.ERROR;
                                 }
                                 else if (!ValidateTypes.getType(typeTable.getTableTypeCurrentHash()).equals(exp.toString())){
                                    errorSemanticoEncontrado(ValidateTypes.getType(typeTable.getTableTypeCurrentHash()) + " -> " + exp.toString(),
                                       "Se intenta retornar un tipo distinto al de la función");
                                       RESULT = ValidateTypes.ERROR;
                                 }
                                 RESULT = "ok";
                             :};

/********************** Generales **********************/
factor ::= IDENTIFICADOR:id  {:
                                if (!existingIdScope(id.toString())){
                                    errorSemanticoEncontrado(id.toString(),
                                    "La variable no se declaró previamente en la función");
                                    RESULT = ValidateTypes.ERROR;
                                }
                                else if (typeTable.getRowStatus(id.toString()).equals("declarado")){
                                   errorSemanticoEncontrado(id.toString(),
                                   "La variable no se le ha asignado un valor");
                                   RESULT = ValidateTypes.ERROR;
                                }
                                else {
                                    RESULT = ValidateTypes.getType(typeTable.getRowTypeCurrentHash(id.toString()));
                                }
                            :}
        | IDENTIFICADOR:id CORCHETE_A expresion_aritmetica:exp CORCHETE_C
         {:
            if (!existingIdScope(id.toString())){
                errorSemanticoEncontrado(id.toString(),
                "La variable no se declaró previamente en la función");
                RESULT = ValidateTypes.ERROR;
            }
            else if (!ValidateTypes.validateNumber(exp.toString())){
              errorSemanticoEncontrado(exp.toString(),
              "La posición del arreglo debe ser un valor entero");
              RESULT = ValidateTypes.ERROR;
            }
            else if (typeTable.getRowStatus(id.toString()).equals("declarado")){
               errorSemanticoEncontrado(id.toString(),
               "La variable no se le ha asignado un valor");
               RESULT = ValidateTypes.ERROR;
            }
            else {
                RESULT = ValidateTypes.getType(typeTable.getRowTypeCurrentHash(id.toString()));
            }
        :}
        | literales:i  {: RESULT = ValidateTypes.getType(i.toString()); :}
        | operacion_unaria:i  {: RESULT = ValidateTypes.getType(i.toString()); :}
        | num_negativos:i  {: RESULT = ValidateTypes.getType(i.toString()); :}
        | func_call:i  {: RESULT = ValidateTypes.getType(i.toString()); :};

func_call ::= IDENTIFICADOR:i parametros_call:p {:
                                                    boolean flag_param = ValidateTypes.validateCallFuncTypes(p.toString(),
                                                                                typeTable.getTableParamsType(i.toString()));
                                                    if (!existingFunction(i.toString())) {
                                                        errorSemanticoEncontrado(i.toString(),
                                                        "La función no se ha declarado");
                                                        RESULT = ValidateTypes.ERROR;
                                                    }
                                                    else if (!flag_param) {
                                                        errorSemanticoEncontrado(i.toString(),
                                                        "Los parámetros de la función no coinciden con la llamada");
                                                        RESULT = ValidateTypes.ERROR;
                                                    }
                                                    else {
                                                        RESULT = typeTable.getTableType(i.toString());
                                                    }
                                                :};

parametros_call ::= PARENTESIS_A PARENTESIS_C {: RESULT = "null"; :}
             | PARENTESIS_A param_call_aux:p PARENTESIS_C {: RESULT = p.toString(); :};

param_call_aux ::= expresion:p  {: RESULT = p.toString(); :}
                 | param_call_aux:p1 COMA expresion:p2  {: RESULT = p1.toString() + ":" + p2.toString(); :};

tipos ::= INTEGER:i {: RESULT = i.toString(); :}
        | FLOAT:i {: RESULT = i.toString(); :}
        | CHAR:i {: RESULT = i.toString(); :}
        | STRING:i {: RESULT = i.toString(); :}
        | BOOL:i {: RESULT = i.toString(); :};

literales ::= LIT_INTEGER:i {: RESULT = i.toString(); :}
            | LIT_FLOAT:i {: RESULT = i.toString(); :}
            | LIT_CHAR:i {: RESULT = i.toString(); :}
            | LIT_STRING:i {: RESULT = i.toString(); :}
            | LIT_BOOL:i {: RESULT = i.toString(); :};

num_negativos ::= NEGATIVO LIT_INTEGER:i {: RESULT = i.toString(); :}
                | NEGATIVO LIT_FLOAT:i {: RESULT = i.toString(); :}
                | NEGATIVO IDENTIFICADOR:id {:
                                                if (!existingIdScope(id.toString())){
                                                    errorSemanticoEncontrado(id.toString(),
                                                    "El identificador no se declaró previamente en la función");
                                                    RESULT = ValidateTypes.ERROR;
                                                }
                                                else if (!validateNumber(id.toString())){
                                                    errorSemanticoEncontrado(id.toString(),
                                                    "El identificador debe ser de tipo entero o float");
                                                    RESULT = ValidateTypes.ERROR;
                                                }
                                                else if (typeTable.getRowStatus(id.toString()).equals("declarado")){
                                                   errorSemanticoEncontrado(id.toString(),
                                                   "La variable no se le ha asignado un valor");
                                                   RESULT = ValidateTypes.ERROR;
                                                }
                                                else {
                                                    RESULT = typeTable.getRowTypeCurrentHash(id.toString());
                                                }
                                            :};

operacion_unaria ::= IDENTIFICADOR:id operadores_unarios
                    {:
                        if (!existingIdScope(id.toString())){
                           errorSemanticoEncontrado(id.toString(),
                           "El identificador no se declaró previamente en la función");
                           RESULT = ValidateTypes.ERROR;
                        }
                        else if (!validateNumber(id.toString())){
                           errorSemanticoEncontrado(id.toString(),
                           "El identificador debe ser de tipo entero o float");
                           RESULT = ValidateTypes.ERROR;
                        }
                        else if (typeTable.getRowStatus(id.toString()).equals("declarado")){
                           errorSemanticoEncontrado(id.toString(),
                           "La variable no se le ha asignado un valor");
                           RESULT = ValidateTypes.ERROR;
                        }
                        else {
                           RESULT = typeTable.getRowTypeCurrentHash(id.toString());
                        }
                    :};

valores_arreglos ::= expresion:exp {: RESULT = ValidateTypes.getType(exp.toString()); :}
                    | valores_arreglos:exp_1 COMA expresion:exp_2
                        {:
                           String expS_1 = ValidateTypes.getType(exp_1.toString());
                           String expS_2 = ValidateTypes.getType(exp_2.toString());
                           if (expS_1.equals(ValidateTypes.ERROR) || expS_2.toString().equals(ValidateTypes.ERROR)) {
                               RESULT = ValidateTypes.ERROR;
                           }
                           else if (!expS_1.equals(expS_2)) {
                               RESULT = ValidateTypes.ERROR;
                           }
                           else{
                               RESULT = ValidateTypes.getType(expS_1.toString());
                           }
                       :};

/********************** Operadores **********************/
operadores_aritmeticos ::= SUMA:i {: RESULT = i.toString(); :}
                | RESTA:i {: RESULT = i.toString(); :}
                | MULTIPLICACION:i {: RESULT = i.toString(); :}
                | DIVISION:i {: RESULT = i.toString(); :}
                | MODULO:i {: RESULT = i.toString(); :}
                | POTENCIA:i {: RESULT = i.toString(); :};

operadores_relacionales ::= MENOR:i {: RESULT = i.toString(); :}
                    | MENOR_IGUAL:i {: RESULT = i.toString(); :}
                    | MAYOR:i {: RESULT = i.toString(); :}
                    | MAYOR_IGUAL:i {: RESULT = i.toString(); :}
                    | IGUALDAD:i {: RESULT = i.toString(); :}
                    | DIFERENTE:i {: RESULT = i.toString(); :};

operadores_logicos ::= CONJUNCION:i {: RESULT = i.toString(); :}
                | DISYUNCION:i {: RESULT = i.toString(); :};

operadores_unarios ::= INCREMENTO:i {: RESULT = i.toString(); :}
                    | DECREMENTO:i {: RESULT = i.toString(); :};