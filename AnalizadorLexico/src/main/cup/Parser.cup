package cup;

import java_cup.runtime.*;
import jflex.LexerCup;

action code
{:

    public void hola(){
        System.out.println("Hola mundo");
    }

:}

parser code {:

    int contadorErrores = 0;

    LexerCup lexer;

    @SuppressWarnings("deprecation")
    public parser(LexerCup lexer){
        this.lexer = lexer;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    public void syntax_error(Symbol s){
        System.out.println("");
        System.out.println("Error R de sintáxis:" + s.value);
        System.out.println("Línea:" + (s.left+1));
        System.out.println("Columna:" + (s.right+1));
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("");
        System.out.println("Error NR de sintáxis:" + s.value);
        System.out.println("Línea:" + (s.left+1));
        System.out.println("Columna:" + (s.right+1));
    }

:}

init with {: :};

scan with {: return lexer.next_token(); :};

// Terminales
terminal MAIN, IDENTIFICADOR; /* Identificadores */
terminal INTEGER, FLOAT, BOOL, CHAR, STRING; /* Tipos */
terminal LIT_INTEGER, LIT_FLOAT, LIT_CHAR, LIT_STRING, LIT_BOOL; /* Objetos */
terminal SUMA, RESTA, DIVISION, MULTIPLICACION,
        MODULO, POTENCIA, INCREMENTO, DECREMENTO; /* Operadores aritméticos */
terminal MENOR, MENOR_IGUAL, MAYOR,
        MAYOR_IGUAL, IGUALDAD, DIFERENTE; /* Operadores relacionales */
terminal CONJUNCION, DISYUNCION, NEGACION; /* Operadores lógicos */
terminal IF, ELSE, WHILE, FOR,
        SWITCH, CASE, DEFAULT, BREAK,
        RETURN, DOS_PUNTOS; /* Estructuras de control */
terminal COMA, PUNTO_COMA, BLOQUE_A,
        BLOQUE_C, CORCHETE_A, CORCHETE_C,
        PARENTESIS_A, PARENTESIS_C, ASIGNACION,
        DELIMITADOR; /* Símbolos de estructura */
terminal PRINT, READ; /* Operaciones de lectura */

// No terminales
non terminal programa, main; /* Main */
non terminal funciones, funcion, encabezado_func; /* Funciones */
non terminal parametros, paramAux, parametro; /* Parámetros */
non terminal bloque, instrucciones, sentencia; /* Bloques */
non terminal creacion, creacion_unica, creacion_asign; /* Creaciones */
non terminal asign; /* Asignaciones */
non terminal condicional_else, condicional_aux, condicional; /* Condicionales */
non terminal iteracion, iteracion_while, iteracion_for; /* Iteraciones */
non terminal switch, casos_con_default, casos, caso; /* Switch */
non terminal salida, entrada; /* Entrada y salida */
non terminal break; /* Break */
non terminal retorno; /* Retorno */
non terminal expresion_booleana, expresion, expresion_aux, expresion_unaria_cadena, expresion_unaria_entero, expresion_arit, factor, expresion_rel, expresion_logica; /* Expresiones */
non terminal tipos, literales, operadores_arit, operadores_rel_num, operadores_log; /* Generales */

// Precedencia
precedence left INCREMENTO, DECREMENTO;
precedence left SUMA, RESTA;
precedence left DIVISION, MULTIPLICACION;
precedence left MODULO;
precedence left POTENCIA;

precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;

precedence left CONJUNCION, DISYUNCION;
precedence left NEGACION;

precedence left DELIMITADOR, PARENTESIS_C, IF;

// Producciones
// Inicio
start with programa;

// Generales
tipos ::= INTEGER:i {: RESULT = i.toString(); :}
        | FLOAT:i {: RESULT = i.toString(); :}
        | CHAR:i {: RESULT = i.toString(); :}
        | STRING:i {: RESULT = i.toString(); :}
        | BOOL:i {: RESULT = i.toString(); :};
//tipos_arreglos ::= INTEGER | CHAR;
literales ::= LIT_INTEGER:i {: RESULT = i.toString(); :}
            | LIT_FLOAT:i {: RESULT = i.toString(); :}
            | LIT_CHAR:i {: RESULT = i.toString(); :}
            | LIT_STRING:i {: RESULT = i.toString(); :}
            | LIT_BOOL:i {: RESULT = i.toString(); :};

operadores_arit ::= SUMA:i {: RESULT = i.toString(); :}
                | RESTA:i {: RESULT = i.toString(); :}
                | MULTIPLICACION:i {: RESULT = i.toString(); :}
                | DIVISION:i {: RESULT = i.toString(); :}
                | MODULO:i {: RESULT = i.toString(); :}
                | POTENCIA:i {: RESULT = i.toString(); :};
operadores_rel_num ::= MENOR:i {: RESULT = i.toString(); :}
                    | MENOR_IGUAL:i {: RESULT = i.toString(); :}
                    | MAYOR:i {: RESULT = i.toString(); :}
                    | MAYOR_IGUAL:i {: RESULT = i.toString(); :}
                    | IGUALDAD:i {: RESULT = i.toString(); :}
                    | DIFERENTE:i {: RESULT = i.toString(); :};
operadores_log ::= CONJUNCION:i {: RESULT = i.toString(); :}
                | DISYUNCION:i {: RESULT = i.toString(); :}
                | NEGACION:i {: RESULT = i.toString(); :};

// Main
programa ::= main {: if (contadorErrores == 0){
                       System.out.println("Código semánticamente bien estructurado");
                     }
                     else{
                       throw new Error("Cantidad de errores semánticos encontrados: " + contadorErrores);
                     }
                   :};
main ::= MAIN DOS_PUNTOS funciones;

// Funciones
funciones ::= funcion
            | funciones funcion;
funcion ::= encabezado_func bloque;
encabezado_func ::= tipos IDENTIFICADOR parametros;

// Parametros
parametros ::= PARENTESIS_A PARENTESIS_C | PARENTESIS_A paramAux PARENTESIS_C;
paramAux ::= parametro | paramAux COMA parametro;
parametro ::= tipos IDENTIFICADOR;

// Bloques
bloque ::= BLOQUE_A instrucciones BLOQUE_C DELIMITADOR;
instrucciones ::= sentencia | instrucciones sentencia;
sentencia ::= expresion
            | creacion
            | asign
            | condicional_else
            | iteracion
            | switch
            | salida
            | entrada
            | retorno
            | error:e DELIMITADOR {:
                                    contadorErrores += 1;
                                    System.out.println("Sentencia mal estructurada");
                                    System.out.println("Revise la semántica");
                                  :};


// Creaciones
creacion ::= creacion_unica
            | creacion_asign;
creacion_unica ::= tipos IDENTIFICADOR DELIMITADOR;
            //| tipos_arreglos IDENTIFICADOR CORCHETE_A INTEGER CORCHETE_C DELIMITADOR;
creacion_asign ::= tipos IDENTIFICADOR ASIGNACION literales DELIMITADOR
                | tipos IDENTIFICADOR ASIGNACION IDENTIFICADOR DELIMITADOR
                | tipos IDENTIFICADOR ASIGNACION expresion_aux DELIMITADOR
                | tipos IDENTIFICADOR ASIGNACION entrada DELIMITADOR;
                //| tipos_arreglos IDENTIFICADOR CORCHETE_A INTEGER CORCHETE_C ASIGNACION CORCHETE_A (asignArreglosAux){INTEGER} CORCHETE_C DELIMITADOR;

// Asignaciones
asign ::= IDENTIFICADOR ASIGNACION literales DELIMITADOR
                | IDENTIFICADOR ASIGNACION IDENTIFICADOR DELIMITADOR
                | IDENTIFICADOR ASIGNACION expresion_aux DELIMITADOR
                | IDENTIFICADOR ASIGNACION entrada DELIMITADOR;
/*
asignArreglosAux ::= asignArreglos | asignArreglosAux COMA asignArreglos;
asignArreglos ::= INTEGER | IDENTIFICADOR | CHAR;
*/

// Condicionales
condicional_else ::= condicional_aux
                    | condicional_aux ELSE bloque;
condicional_aux ::= condicional
                    | condicional_aux condicional;
condicional ::= IF PARENTESIS_A expresion_booleana PARENTESIS_C bloque;

// Iteraciones
iteracion ::= iteracion_while
            | iteracion_for;
iteracion_while ::= WHILE PARENTESIS_A expresion_booleana PARENTESIS_C bloque;
iteracion_for ::= FOR PARENTESIS_A creacion_asign PUNTO_COMA expresion_aux PUNTO_COMA creacion_asign PARENTESIS_C bloque;

// Switch
switch ::= SWITCH PARENTESIS_A IDENTIFICADOR PARENTESIS_C BLOQUE_A casos_con_default BLOQUE_C;
casos_con_default ::= casos DEFAULT DOS_PUNTOS bloque;
casos ::= caso
        | casos caso;
caso ::= CASE literales DOS_PUNTOS bloque break;

// Entrada y salida
salida ::= PRINT PARENTESIS_A expresion_aux PARENTESIS_C DELIMITADOR
        | PRINT PARENTESIS_A literales PARENTESIS_C DELIMITADOR;
entrada ::= READ PARENTESIS_A PARENTESIS_C DELIMITADOR;

// Break
break ::= BREAK DELIMITADOR;

// Retorno
retorno ::= RETURN DELIMITADOR
            | RETURN expresion_aux DELIMITADOR;

// Expresiones
expresion_booleana ::= expresion_rel DELIMITADOR
                    | expresion_logica DELIMITADOR;
expresion ::= expresion_aux DELIMITADOR;
expresion_aux ::= expresion_arit
            | expresion_rel
            | expresion_logica
            | expresion_unaria_cadena;
expresion_unaria_cadena ::= IDENTIFICADOR SUMA RESTA;
expresion_unaria_entero ::= IDENTIFICADOR INCREMENTO
                        | IDENTIFICADOR DECREMENTO
                        | INTEGER INCREMENTO
                        | INTEGER DECREMENTO;
expresion_arit ::= expresion_arit operadores_arit factor
                | factor;
factor ::= IDENTIFICADOR
        | literales
        | expresion_unaria_entero
        | PARENTESIS_A expresion_aux PARENTESIS_C;
expresion_rel ::= expresion_aux operadores_rel_num expresion_aux;
expresion_logica ::= expresion_logica operadores_log expresion_aux
                | NEGACION expresion_aux;